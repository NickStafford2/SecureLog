#include <cstring>
#include <openssl/err.h>
#include <openssl/evp.h>
#include <openssl/kdf.h>
#include <openssl/rand.h>
#include <stdexcept>
#include <vector>

#include "crypto.h"
namespace {
class CipherContext {
public:
  CipherContext() : ctx(EVP_CIPHER_CTX_new()) {
    if (!ctx)
      throw std::runtime_error("Failed to create cipher context");
  }
  ~CipherContext() { EVP_CIPHER_CTX_free(ctx); }
  EVP_CIPHER_CTX *get() { return ctx; }

private:
  EVP_CIPHER_CTX *ctx;
};
} // namespace

Crypto::Crypto() {
  OPENSSL_init_crypto(
      OPENSSL_INIT_ADD_ALL_CIPHERS | OPENSSL_INIT_ADD_ALL_DIGESTS, nullptr);
}

Crypto::~Crypto() {
  // Cleanup is automatically handled by OPENSSL_cleanup()
}

void Crypto::handleOpenSSLError(const char *location) {
  char err_buf[256];
  ERR_error_string_n(ERR_get_error(), err_buf, sizeof(err_buf));
  throw std::runtime_error(std::string(location) + ": " + err_buf);
}

std::vector<unsigned char> Crypto::generateKey(const std::string &password) {
  if (password.empty()) {
    std::vector<unsigned char> key(KEY_LENGTH);
    if (RAND_bytes(key.data(), KEY_LENGTH) != 1) {
      handleOpenSSLError("Key generation failed");
    }
    return key;
  } else {
    auto salt = generateSalt();
    return deriveKey(password, salt);
  }
}

std::vector<unsigned char> Crypto::generateSalt() {
  std::vector<unsigned char> salt(SALT_LENGTH);
  if (RAND_bytes(salt.data(), SALT_LENGTH) != 1) {
    handleOpenSSLError("Salt generation failed");
  }
  return salt;
}

std::vector<unsigned char>
Crypto::deriveKey(const std::string &password,
                  const std::vector<unsigned char> &salt) {
  std::vector<unsigned char> key(KEY_LENGTH);

  if (PKCS5_PBKDF2_HMAC(password.c_str(), password.length(), salt.data(),
                        salt.size(), ITERATION_COUNT, EVP_sha256(), KEY_LENGTH,
                        key.data()) != 1) {
    handleOpenSSLError("Key derivation failed");
  }

  return key;
}

Crypto::CryptoResult Crypto::encrypt(const std::string &plainText,
                                     const std::vector<unsigned char> &key,
                                     const std::string &additionalData) {
  if (key.size() != KEY_LENGTH) {
    throw std::invalid_argument("Invalid key length");
  }

  CryptoResult result;
  result.data.resize(plainText.size() + EVP_MAX_BLOCK_LENGTH);
  result.tag.resize(TAG_LENGTH);

  std::vector<unsigned char> iv(IV_LENGTH);
  if (RAND_bytes(iv.data(), IV_LENGTH) != 1) {
    handleOpenSSLError("IV generation failed");
  }

  CipherContext ctx;
  if (EVP_EncryptInit_ex(ctx.get(), EVP_aes_256_gcm(), nullptr, nullptr,
                         nullptr) != 1) {
    handleOpenSSLError("Encryption initialization failed");
  }

  if (EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_SET_IVLEN, IV_LENGTH,
                          nullptr) != 1) {
    handleOpenSSLError("IV length set failed");
  }

  if (EVP_EncryptInit_ex(ctx.get(), nullptr, nullptr, key.data(), iv.data()) !=
      1) {
    handleOpenSSLError("Key/IV initialization failed");
  }

  int len;
  if (!additionalData.empty()) {
    if (EVP_EncryptUpdate(
            ctx.get(), nullptr, &len,
            reinterpret_cast<const unsigned char *>(additionalData.data()),
            additionalData.size()) != 1) {
      handleOpenSSLError("AAD update failed");
    }
  }

  int cipherTextLen;
  if (EVP_EncryptUpdate(
          ctx.get(), result.data.data(), &cipherTextLen,
          reinterpret_cast<const unsigned char *>(plainText.data()),
          plainText.size()) != 1) {
    handleOpenSSLError("Encryption update failed");
  }

  int finalLen;
  if (EVP_EncryptFinal_ex(ctx.get(), result.data.data() + cipherTextLen,
                          &finalLen) != 1) {
    handleOpenSSLError("Encryption finalization failed");
  }

  if (EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_GET_TAG, TAG_LENGTH,
                          result.tag.data()) != 1) {
    handleOpenSSLError("Tag generation failed");
  }

  result.data.resize(cipherTextLen + finalLen);
  result.data.insert(result.data.begin(), iv.begin(), iv.end());

  return result;
}

std::string Crypto::decrypt(const CryptoResult &cryptoResult,
                            const std::vector<unsigned char> &key,
                            const std::string &additionalData) {
  if (key.size() != KEY_LENGTH) {
    throw std::invalid_argument("Invalid key length");
  }

  if (cryptoResult.data.size() <= IV_LENGTH) {
    throw std::invalid_argument("Invalid ciphertext length");
  }

  std::vector<unsigned char> iv(cryptoResult.data.begin(),
                                cryptoResult.data.begin() + IV_LENGTH);

  std::vector<unsigned char> plainText(cryptoResult.data.size() - IV_LENGTH);

  CipherContext ctx;
  if (EVP_DecryptInit_ex(ctx.get(), EVP_aes_256_gcm(), nullptr, nullptr,
                         nullptr) != 1) {
    handleOpenSSLError("Decryption initialization failed");
  }

  if (EVP_CIPHER_CTX_ctrl(ctx.get(), EVP_CTRL_GCM_SET_IVLEN, IV_LENGTH,
                          nullptr) != 1) {
    handleOpenSSLError("IV length set failed");
  }

  if (EVP_DecryptInit_ex(ctx.get(), nullptr, nullptr, key.data(), iv.data()) !=
      1) {
    handleOpenSSLError("Key/IV initialization failed");
  }

  int len;
  if (!additionalData.empty()) {
    if (EVP_DecryptUpdate(
            ctx.get(), nullptr, &len,
            reinterpret_cast<const unsigned char *>(additionalData.data()),
            additionalData.size()) != 1) {
      handleOpenSSLError("AAD update failed");
    }
  }

  int plainTextLen;
  if (EVP_DecryptUpdate(ctx.get(), plainText.data(), &plainTextLen,
                        cryptoResult.data.data() + IV_LENGTH,
                        cryptoResult.data.size() - IV_LENGTH) != 1) {
    handleOpenSSLError("Decryption update failed");
  }

  if (EVP_CIPHER_CTX_ctrl(
          ctx.get(), EVP_CTRL_GCM_SET_TAG, TAG_LENGTH,
          const_cast<unsigned char *>(cryptoResult.tag.data())) != 1) {
    handleOpenSSLError("Tag verification failed");
  }

  int finalLen;
  if (EVP_DecryptFinal_ex(ctx.get(), plainText.data() + plainTextLen,
                          &finalLen) != 1) {
    throw std::runtime_error(
        "Authentication failed: message has been tampered with");
  }

  plainText.resize(plainTextLen + finalLen);
  return std::string(plainText.begin(), plainText.end());
}
